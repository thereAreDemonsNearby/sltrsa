#include "../biguint.hpp"
#include "../fullMultiply_alter.hpp"
#include "../TimerGuard.h"

void correctness()
{
    const size_t B = 1024;
    for (int i = 0; i < 100; ++i) {
        auto a = BigUInt<B>::randomGen();
        auto b = BigUInt<B>::randomGen();
        auto res1 = fullMultiply(a, b);
        auto res2 = fullMultiply_comba(a, b);
        if (res1 != res2) {
            fmt::print("not equal\n");
            std::exit(1);
        }
    }
}

int main()
{
    correctness();
    constexpr size_t B = 2048;
    std::vector<BigUInt<B>> vec;
    for (int i = 0; i < 10001; ++i) {
        vec.push_back(BigUInt<B>::randomGen());
    }
    std::vector<BigUInt<B+B>> rv1, rv2, rv3;
    rv1.reserve(vec.size()-1);
    rv2.reserve(vec.size()-1);
    rv3.reserve(vec.size()-1);
    
    {
        TimerGuard rg("normal:");
        for (int i = 0; i < vec.size()-1; ++i) {
            auto res = fullMultiply(vec[i], vec[i+1]);
            // rv1.emplace_back(std::move(res));
        }        
    }

    {
        TimerGuard tg("comba16:");
        for (int i = 0; i < vec.size()-1; ++i) {
            auto res = fullMultiply_comba16(vec[i], vec[i+1]);
            // rv2.emplace_back(std::move(res));
        }
    }

    {
        TimerGuard tg("comba16 simd:");
        for (int i = 0; i < vec.size()-1; ++i) {
            auto res = fullMultiply_comba16_simd(vec[i], vec[i+1]);
        }
    }

    {
        TimerGuard tg("comba: ");
        for (int i = 0; i < vec.size()-1; ++i) {
            auto res = fullMultiply_comba(vec[i], vec[i+1]);
        }
    }

    

    // to slow to deserve a test
    // {
    //     TimerGuard tg("comba openmp: ");
    //     for (int i = 0; i < vec.size()-1; ++i) {
    //         auto res = fullMultiply_comba_openmp(vec[i], vec[i+1]);
    //     }
    // }
}
